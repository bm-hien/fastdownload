<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CloudFlare Download Manager</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <style>
        :root {
            --primary: #4f46e5;
            --success: #22c55e;
            --error: #ef4444;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background: #f3f4f6;
            color: #1f2937;
        }

        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            background: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h1 {
            color: var(--primary);
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: #6b7280;
            margin: 0;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: all 0.3s;
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #4338ca;
        }

        .download-card {
            display: none;
            background: #f8fafc;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 2rem;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .file-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .file-details h3 {
            margin: 0;
            font-size: 1.1rem;
            color: #334155;
        }

        .file-details p {
            margin: 0;
            color: #64748b;
            font-size: 0.9rem;
        }

        .progress-container {
            margin-bottom: 1rem;
        }

        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress {
            width: 0%;
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            text-align: center;
        }

        .stat-item {
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 500;
            color: var(--primary);
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #64748b;
        }

        .advanced-options {
            margin-top: 1rem;
            padding: 1rem;
            background: #f1f5f9;
            border-radius: 0.5rem;
            display: none;
        }

        .option-title {
            font-weight: 500;
            color: #334155;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            cursor: pointer;
        }

        .option-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .option-item label {
            font-size: 0.9rem;
            color: #475569;
        }

        @media (max-width: 640px) {
            .container {
                margin: 1rem;
                padding: 1rem;
            }

            .input-group {
                flex-direction: column;
            }

            .stats {
                grid-template-columns: 1fr;
            }
            
            .option-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CloudFlare Download Manager</h1>
            <p>T·∫£i file nhanh v√† an to√†n qua CloudFlare Worker</p>
        </div>

        <div class="input-group">
            <input type="text" id="urlInput" placeholder="Nh·∫≠p URL file c·∫ßn t·∫£i..." />
            <button onclick="startDownload()">T·∫£i xu·ªëng</button>
        </div>
        
        <div class="option-title" onclick="toggleAdvancedOptions()">
            <span>T√πy ch·ªçn n√¢ng cao</span>
            <span id="optionsToggle">‚ñº</span>
        </div>
        
        <div id="advancedOptions" class="advanced-options">
            <div class="option-content">
                <div class="option-item">
                    <input type="checkbox" id="chunkDownload" checked>
                    <label for="chunkDownload">T·∫£i theo ƒëo·∫°n (tƒÉng t·ªëc)</label>
                </div>
                <div class="option-item">
                    <input type="number" id="chunkSize" value="5" min="1" max="20" style="width: 60px">
                    <label for="chunkSize">K√≠ch th∆∞·ªõc ƒëo·∫°n (MB)</label>
                </div>
                <div class="option-item">
                    <input type="number" id="concurrentChunks" value="3" min="1" max="10" style="width: 60px">
                    <label for="concurrentChunks">S·ªë lu·ªìng song song</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="useHttp3" checked>
                    <label for="useHttp3">S·ª≠ d·ª•ng HTTP/3 (QUIC)</label>
                </div>
            </div>
        </div>

        <div id="downloadCard" class="download-card">
            <div class="file-info">
                <div class="file-icon">üìÅ</div>
                <div class="file-details">
                    <h3 id="filename">ƒêang t·∫£i...</h3>
                    <p id="filesize">K√≠ch th∆∞·ªõc: ...</p>
                </div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progress" class="progress"></div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <div id="downloadedSize" class="stat-value">0 MB</div>
                    <div class="stat-label">ƒê√£ t·∫£i</div>
                </div>
                <div class="stat-item">
                    <div id="speed" class="stat-value">0 MB/s</div>
                    <div class="stat-label">T·ªëc ƒë·ªô</div>
                </div>
                <div class="stat-item">
                    <div id="timeRemaining" class="stat-value">--:--</div>
                    <div class="stat-label">Th·ªùi gian c√≤n l·∫°i</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleAdvancedOptions() {
            const options = document.getElementById('advancedOptions');
            const toggle = document.getElementById('optionsToggle');
            
            if (options.style.display === 'none' || options.style.display === '') {
                options.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                options.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }
    
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }

        function formatTime(seconds) {
            if (seconds < 60) return Math.round(seconds) + ' gi√¢y';
            if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.round(seconds % 60);
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
            return (seconds / 3600).toFixed(1) + ' gi·ªù';
        }
        
        async function downloadChunk(url, start, end) {
            const response = await fetch(url, {
                headers: {
                    'Range': `bytes=${start}-${end}`
                }
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return await response.arrayBuffer();
        }
        
        // H√†m ƒë·ªÉ th·ª±c hi·ªán c√°c promise v·ªõi s·ªë l∆∞·ª£ng song song gi·ªõi h·∫°n
        async function promisePool(promiseFuncs, poolLimit) {
            let results = [];
            const executing = new Set();
            
            async function executePromise(promiseFunc, index) {
                const promise = promiseFunc();
                executing.add(promise);
                
                try {
                    const result = await promise;
                    results[index] = result;
                } catch (error) {
                    results[index] = null;
                    throw error;
                } finally {
                    executing.delete(promise);
                }
                
                return promise;
            }
            
            for (let i = 0; i < promiseFuncs.length; i++) {
                if (executing.size >= poolLimit) {
                    await Promise.race(executing);
                }
                
                executePromise(promiseFuncs[i], i).catch(error => {
                    console.error(`Error downloading chunk ${i}:`, error);
                });
            }
            
            await Promise.all(executing);
            return results;
        }
        
        async function downloadWithChunks(url, contentLength, chunkSizeMB, concurrentChunks) {
            const chunkSize = chunkSizeMB * 1024 * 1024; // Convert to bytes
            const numChunks = Math.ceil(contentLength / chunkSize);
            const chunks = [];
            
            // Create array of promise-returning functions
            const downloadFunctions = [];
            for (let i = 0; i < numChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize - 1, contentLength - 1);
                
                downloadFunctions.push(() => downloadChunk(url, start, end));
            }
            
            const startTime = Date.now();
            let lastBytes = 0;
            let lastTime = startTime;
            let receivedBytes = 0;
            
            // Monitor progress
            const progressInterval = setInterval(() => {
                const currentTime = Date.now();
                const timeDiff = (currentTime - lastTime) / 1000;
                
                if (timeDiff > 0.5) {
                    const bytesDiff = receivedBytes - lastBytes;
                    const speed = bytesDiff / timeDiff;
                    document.getElementById('speed').textContent = formatSize(speed) + '/s';
                    
                    const remainingBytes = contentLength - receivedBytes;
                    const timeRemaining = remainingBytes / speed;
                    document.getElementById('timeRemaining').textContent = formatTime(timeRemaining);
                    
                    lastBytes = receivedBytes;
                    lastTime = currentTime;
                }
            }, 500);
            
            try {
                // Download chunks with limited concurrency
                const downloadedChunks = await promisePool(downloadFunctions, concurrentChunks);
                
                clearInterval(progressInterval);
                
                // Combine chunks
                const blob = new Blob(downloadedChunks, { type: 'application/octet-stream' });
                const blobUrl = URL.createObjectURL(blob);
                
                return blobUrl;
            } catch (error) {
                clearInterval(progressInterval);
                throw error;
            }
        }

        async function startDownload() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) {
                alert('Vui l√≤ng nh·∫≠p URL!');
                return;
            }

            const downloadCard = document.getElementById('downloadCard');
            downloadCard.style.display = 'block';

            const encoded = encodeURIComponent(url);
            const useHttp3 = document.getElementById('useHttp3').checked;
            const proxyUrl = `/proxy?url=${encoded}&http3=${useHttp3}`;

            try {
                const response = await fetch(proxyUrl, { method: 'HEAD' });
                const contentLength = parseInt(response.headers.get('content-length') || '0');
                const fileName = response.headers.get('content-disposition')?.split('filename=')[1]?.replace(/"/g, '') || 'file';

                document.getElementById('filename').textContent = fileName;
                document.getElementById('filesize').textContent = 'K√≠ch th∆∞·ªõc: ' + formatSize(contentLength);

                // Check if we should use chunked download
                const useChunkedDownload = document.getElementById('chunkDownload').checked && contentLength > 5 * 1024 * 1024; // Only use for files > 5MB
                
                if (useChunkedDownload) {
                    const chunkSizeMB = parseInt(document.getElementById('chunkSize').value) || 5;
                    const concurrentChunks = parseInt(document.getElementById('concurrentChunks').value) || 3;
                    
                    try {
                        // Start chunked download with progress reporting
                        const startTime = Date.now();
                        let lastBytes = 0;
                        let lastTime = startTime;
                        let receivedBytes = 0;
                        
                        // Set up progress reporting
                        const progressUpdate = (loadedBytes) => {
                            receivedBytes = loadedBytes;
                            const progress = (receivedBytes / contentLength) * 100;
                            document.getElementById('progress').style.width = progress + '%';
                            document.getElementById('downloadedSize').textContent = formatSize(receivedBytes);
                        };
                        
                        // Monitor chunked download progress (simulate with interval)
                        let loadedSoFar = 0;
                        const simulateProgress = setInterval(() => {
                            loadedSoFar += Math.random() * 2 * 1024 * 1024; // Simulate 0-2MB progress
                            if (loadedSoFar > contentLength) loadedSoFar = contentLength;
                            progressUpdate(loadedSoFar);
                            
                            if (loadedSoFar >= contentLength) {
                                clearInterval(simulateProgress);
                            }
                        }, 250);
                        
                        const blobUrl = await downloadWithChunks(proxyUrl, contentLength, chunkSizeMB, concurrentChunks);
                        clearInterval(simulateProgress);
                        
                        // Complete progress
                        progressUpdate(contentLength);
                        
                        // Create download link
                        const a = document.createElement('a');
                        a.href = blobUrl;
                        a.download = fileName;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
                        
                    } catch (error) {
                        console.error('Chunked download failed, falling back to regular download:', error);
                        window.open(proxyUrl, '_blank');
                    }
                } else {
                    // Regular download
                    const startTime = Date.now();
                    let lastBytes = 0;
                    let lastTime = startTime;

                    const response2 = await fetch(proxyUrl);
                    const reader = response2.body.getReader();
                    let receivedBytes = 0;

                    while(true) {
                        const {done, value} = await reader.read();
                        if (done) break;

                        receivedBytes += value.length;
                        const progress = (receivedBytes / contentLength) * 100;
                        document.getElementById('progress').style.width = progress + '%';
                        document.getElementById('downloadedSize').textContent = formatSize(receivedBytes);

                        const currentTime = Date.now();
                        const timeDiff = (currentTime - lastTime) / 1000;
                        if (timeDiff > 0.5) {
                            const bytesDiff = receivedBytes - lastBytes;
                            const speed = bytesDiff / timeDiff;
                            document.getElementById('speed').textContent = formatSize(speed) + '/s';

                            const remainingBytes = contentLength - receivedBytes;
                            const timeRemaining = remainingBytes / speed;
                            document.getElementById('timeRemaining').textContent = formatTime(timeRemaining);

                            lastBytes = receivedBytes;
                            lastTime = currentTime;
                        }
                    }

                    window.open(proxyUrl, '_blank');
                }
            } catch (error) {
                alert('L·ªói khi t·∫£i file: ' + error.message);
            }
        }
    </script>
</body>
</html>
